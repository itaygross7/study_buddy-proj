<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/infra/mongo_client.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/infra/mongo_client.py" />
              <option name="originalContent" value="from typing import Any, Dict, Optional&#10;from pymongo import MongoClient, ASCENDING&#10;import logging&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class MongoClientWrapper:&#10;    def __init__(self, uri: str = &quot;mongodb://localhost:27017&quot;, db_name: str = &quot;studybuddy&quot;):&#10;        self._client = MongoClient(uri, serverSelectionTimeoutMS=2000)&#10;        self.db = self._client[db_name]&#10;        self._ensure_indexes()&#10;&#10;    def _ensure_indexes(self):&#10;        # Example indexes — add as needed for queries (no unique on user content)&#10;        try:&#10;            self.db.jobs.create_index([(&quot;created_at&quot;, ASCENDING)])&#10;        except Exception:&#10;            logger.warning(&quot;Failed to create indexes on MongoDB&quot;, exc_info=True)&#10;&#10;    def insert_job(self, collection: str, job: Dict[str, Any]) -&gt; str:&#10;        # Safe insert; ensure no direct user content used in queries&#10;        res = self.db[collection].insert_one(job)&#10;        return str(res.inserted_id)&#10;&#10;    def find_job(self, collection: str, job_id: Any) -&gt; Optional[Dict]:&#10;        res = self.db[collection].find_one({&quot;_id&quot;: job_id})&#10;        return res&#10;&#10;" />
              <option name="updatedContent" value="from typing import Any, Dict, Optional&#13;&#10;from bson import ObjectId&#13;&#10;from pymongo import MongoClient, ASCENDING&#13;&#10;import logging&#13;&#10;&#13;&#10;logger = logging.getLogger(__name__)&#13;&#10;&#13;&#10;class MongoClientWrapper:&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    Thin wrapper around MongoClient to centralize indexes and safe patterns.&#13;&#10;    &quot;&quot;&quot;&#13;&#10;&#13;&#10;    def __init__(self, uri: str = &quot;mongodb://localhost:27017&quot;, db_name: str = &quot;studybuddy&quot;) -&gt; None:&#13;&#10;        self._client = MongoClient(uri, serverSelectionTimeoutMS=2000)&#13;&#10;        self.db = self._client[db_name]&#13;&#10;        self._ensure_indexes()&#13;&#10;&#13;&#10;    def _ensure_indexes(self) -&gt; None:&#13;&#10;        # Example indexes — add as needed for queries (no unique on user content)&#13;&#10;        try:&#13;&#10;            self.db.jobs.create_index([(&quot;created_at&quot;, ASCENDING)])&#13;&#10;        except Exception:&#13;&#10;            logger.warning(&quot;Failed to create indexes on MongoDB&quot;, exc_info=True)&#13;&#10;&#13;&#10;    def insert_job(self, collection: str, job: Dict[str, Any]) -&gt; str:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Insert a job document and return its ID as string.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        res = self.db[collection].insert_one(job)&#13;&#10;        return str(res.inserted_id)&#13;&#10;&#13;&#10;    def find_job(self, collection: str, job_id: Any) -&gt; Optional[Dict[str, Any]]:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Find a job document by its ID (string or ObjectId).&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        oid = ObjectId(job_id) if not isinstance(job_id, ObjectId) else job_id&#13;&#10;        res = self.db[collection].find_one({&quot;_id&quot;: oid})&#13;&#10;        return res" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/sb_utils/validation.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sb_utils/validation.py" />
              <option name="originalContent" value="from typing import Optional&#10;from .file_utils import allowed_mimetype, MAX_FILE_SIZE_BYTES&#10;import logging&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;# user-facing messages (use enums / constants)&#10;HEBREW_ERRORS = {&#10;    &quot;no_input&quot;: &quot;לא הוזן טקסט או קובץ. אנא העתק טקסט או העלה קובץ.&quot;,&#10;    &quot;bad_type&quot;: &quot;סוג הקובץ אינו נתמך. אנא העלה PDF, DOCX, TXT או תמונה (PNG/JPEG).&quot;,&#10;    &quot;too_large&quot;: &quot;הקובץ גדול מדי. אנא השתמש בקבצים עד 10MB.&quot;,&#10;    &quot;server_error&quot;: &quot;אירעה שגיאה בשרת. נסה שוב מאוחר יותר.&quot;,&#10;}&#10;&#10;def validate_upload(mime: Optional[str], size: int) -&gt; Optional[str]:&#10;    if size &lt;= 0:&#10;        return HEBREW_ERRORS[&quot;no_input&quot;]&#10;    if size &gt; MAX_FILE_SIZE_BYTES:&#10;        return HEBREW_ERRORS[&quot;too_large&quot;]&#10;    if not allowed_mimetype(mime):&#10;        return HEBREW_ERRORS[&quot;bad_type&quot;]&#10;    return None&#10;&#10;" />
              <option name="updatedContent" value="from typing import Optional&#13;&#10;from .file_utils import allowed_mimetype, MAX_FILE_SIZE_BYTES&#13;&#10;import logging&#13;&#10;&#13;&#10;logger = logging.getLogger(__name__)&#13;&#10;&#13;&#10;# user-facing messages (use enums / constants)&#13;&#10;HEBREW_ERRORS = {&#13;&#10;    &quot;no_input&quot;: &quot;לא הוזן טקסט או קובץ. אנא העתק טקסט או העלה קובץ.&quot;,&#13;&#10;    &quot;bad_type&quot;: &quot;סוג הקובץ אינו נתמך. אנא העלה PDF, DOCX, TXT או תמונה (PNG/JPEG).&quot;,&#13;&#10;    &quot;too_large&quot;: &quot;הקובץ גדול מדי. אנא השתמש בקבצים עד 10MB.&quot;,&#13;&#10;    &quot;server_error&quot;: &quot;אירעה שגיאה בשרת. נסה שוב מאוחר יותר.&quot;,&#13;&#10;}&#13;&#10;&#13;&#10;def validate_upload(mime: Optional[str], size: int) -&gt; Optional[str]:&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    Validate upload size and MIME type.&#13;&#10;    Returns a Hebrew error message if invalid, otherwise None.&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    if size &lt;= 0:&#13;&#10;        logger.debug(&quot;Validation failed: empty upload (size=%d)&quot;, size)&#13;&#10;        return HEBREW_ERRORS[&quot;no_input&quot;]&#13;&#10;    if size &gt; MAX_FILE_SIZE_BYTES:&#13;&#10;        logger.debug(&quot;Validation failed: too large (size=%d)&quot;, size)&#13;&#10;        return HEBREW_ERRORS[&quot;too_large&quot;]&#13;&#10;    if not allowed_mimetype(mime):&#13;&#10;        logger.debug(&quot;Validation failed: bad MIME type (%s)&quot;, mime)&#13;&#10;        return HEBREW_ERRORS[&quot;bad_type&quot;]&#13;&#10;    return None" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/services/ai_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/services/ai_service.py" />
              <option name="originalContent" value="from typing import Any, Dict, Optional&#10;import time&#10;import logging&#10;import random&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class AIService:&#10;    &quot;&quot;&quot;&#10;    Wrapper for LLM calls. Retries with exponential backoff, timeout per-call.&#10;    Important: DO NOT log user content or API keys.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, client: Any, timeout_s: int = 20, retries: int = 2):&#10;        self.client = client  # injected LLM client wrapper&#10;        self.timeout_s = timeout_s&#10;        self.retries = retries&#10;&#10;    def call(self, prompt: str, params: Optional[Dict] = None) -&gt; str:&#10;        if not prompt or not prompt.strip():&#10;            raise ValueError(&quot;empty_prompt&quot;)&#10;        params = params or {}&#10;        attempt = 0&#10;        while True:&#10;            try:&#10;                attempt += 1&#10;                # call must honor timeout - client implementation should support it&#10;                response = self.client.generate(prompt=prompt, timeout=self.timeout_s, **params)&#10;                # response must be sanitized by client&#10;                return response&#10;            except Exception as exc:&#10;                logger.debug(&quot;AI call failed attempt %d: %s&quot;, attempt, type(exc).__name__)&#10;                if attempt &gt; self.retries:&#10;                    logger.warning(&quot;AI service unavailable after %d attempts&quot;, attempt)&#10;                    raise&#10;                # backoff with jitter&#10;                backoff = (2 ** attempt) + random.random()&#10;                time.sleep(backoff)&#10;&#10;" />
              <option name="updatedContent" value="from typing import Any, Dict, Optional&#13;&#10;import time&#13;&#10;import logging&#13;&#10;import random&#13;&#10;&#13;&#10;logger = logging.getLogger(__name__)&#13;&#10;&#13;&#10;class AIService:&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    Wrapper for LLM calls. Retries with exponential backoff, timeout per-call.&#13;&#10;    Important: DO NOT log user content or API keys.&#13;&#10;    &quot;&quot;&quot;&#13;&#10;&#13;&#10;    def __init__(self, client: Any, timeout_s: int = 20, retries: int = 2) -&gt; None:&#13;&#10;        self.client = client  # injected LLM client wrapper&#13;&#10;        self.timeout_s = timeout_s&#13;&#10;        self.retries = retries&#13;&#10;&#13;&#10;    def call(self, prompt: str, params: Optional[Dict[str, Any]] = None) -&gt; str:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Perform a robust LLM call with retries.&#13;&#10;        The client is responsible for honoring the timeout parameter.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if not prompt or not prompt.strip():&#13;&#10;            raise ValueError(&quot;empty_prompt&quot;)&#13;&#10;        params = params or {}&#13;&#10;        attempt = 0&#13;&#10;        while True:&#13;&#10;            try:&#13;&#10;                attempt += 1&#13;&#10;                response: str = self.client.generate(&#13;&#10;                    prompt=prompt,&#13;&#10;                    timeout=self.timeout_s,&#13;&#10;                    **params,&#13;&#10;                )&#13;&#10;                return response&#13;&#10;            except Exception as exc:&#13;&#10;                logger.debug(&quot;AI call failed attempt %d: %s&quot;, attempt, type(exc).__name__)&#13;&#10;                if attempt &gt; self.retries:&#13;&#10;                    logger.warning(&quot;AI service unavailable after %d attempts&quot;, attempt)&#13;&#10;                    raise&#13;&#10;                backoff: float = (2 ** attempt) + random.random()&#13;&#10;                time.sleep(backoff)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/services/file_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/services/file_service.py" />
              <option name="originalContent" value="from typing import Optional&#10;import logging&#10;from ..sb_utils.file_utils import save_stream_to_temp, clean_temp_path, UploadedFile&#10;from ..sb_utils.validation import validate_upload, HEBREW_ERRORS&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class FileService:&#10;    &quot;&quot;&quot;&#10;    Handles user files: validation, safe temp storage, lightweight extraction.&#10;    Extraction itself can be implemented using optional libs; here we keep API simple.&#10;    &quot;&quot;&quot;&#10;&#10;    def validate_and_store(self, stream, filename: str) -&gt; UploadedFile:&#10;        uf = save_stream_to_temp(stream, filename)&#10;        # do not log contents or names that could be sensitive (only size/mime)&#10;        logger.debug(&quot;Stored temp file (size=%d, mime=%s)&quot;, uf.size, uf.content_type)&#10;        err = validate_upload(uf.content_type, uf.size)&#10;        if err:&#10;            clean_temp_path(uf.temp_path)&#10;            raise ValueError(err)&#10;        return uf&#10;&#10;    def extract_text(self, uploaded: UploadedFile) -&gt; str:&#10;        # Lightweight extraction: for TXT, read; for others return placeholder instruction.&#10;        # Real extraction should be implemented via dedicated extractors (pdfminer, docx2txt...)&#10;        try:&#10;            if uploaded.content_type == &quot;text/plain&quot;:&#10;                with open(uploaded.temp_path, &quot;r&quot;, encoding=&quot;utf-8&quot;, errors=&quot;ignore&quot;) as f:&#10;                    return f.read()&#10;            # keep fallback small and explicit&#10;            return f&quot;[קובץ נתמך: {uploaded.filename} — טקסט לא הופק אוטומטית]&quot;&#10;        finally:&#10;            # caller decides when to clean&#10;            pass&#10;&#10;" />
              <option name="updatedContent" value="from typing import IO&#13;&#10;import logging&#13;&#10;from sb_utils.file_utils import save_stream_to_temp, clean_temp_path, UploadedFile&#13;&#10;from sb_utils.validation import validate_upload&#13;&#10;&#13;&#10;logger = logging.getLogger(__name__)&#13;&#10;&#13;&#10;class FileService:&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    Handles user files: validation, safe temp storage, lightweight extraction.&#13;&#10;    Extraction itself can be implemented using optional libs; here we keep API simple.&#13;&#10;    &quot;&quot;&quot;&#13;&#10;&#13;&#10;    def validate_and_store(self, stream: IO[bytes], filename: str) -&gt; UploadedFile:&#13;&#10;        uf = save_stream_to_temp(stream, filename)&#13;&#10;        # do not log contents or names that could be sensitive (only size/mime)&#13;&#10;        logger.debug(&quot;Stored temp file (size=%d, mime=%s)&quot;, uf.size, uf.content_type)&#13;&#10;        err = validate_upload(uf.content_type, uf.size)&#13;&#10;        if err:&#13;&#10;            clean_temp_path(uf.temp_path)&#13;&#10;            raise ValueError(err)&#13;&#10;        return uf&#13;&#10;&#13;&#10;    def extract_text(self, uploaded: UploadedFile) -&gt; str:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Lightweight extraction: for TXT, read; for others return placeholder instruction.&#13;&#10;        Real extraction should be implemented via dedicated extractors (pdfminer, docx2txt...).&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        try:&#13;&#10;            if uploaded.content_type == &quot;text/plain&quot;:&#13;&#10;                with open(uploaded.temp_path, &quot;r&quot;, encoding=&quot;utf-8&quot;, errors=&quot;ignore&quot;) as f:&#13;&#10;                    return f.read()&#13;&#10;            # keep fallback small and explicit&#13;&#10;            return f&quot;[קובץ נתמך: {uploaded.filename} — טקסט לא הופק אוטומטית]&quot;&#13;&#10;        finally:&#13;&#10;            # caller decides when to clean&#13;&#10;            pass&#13;&#10;&#13;&#10;    @staticmethod&#13;&#10;    def cleanup(uploaded: UploadedFile) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Public helper so routes/tests do not touch filesystem utils directly.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        clean_temp_path(uploaded.temp_path)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/api.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/api.py" />
              <option name="originalContent" value="from flask import Flask, request, jsonify, render_template&#10;from typing import Dict&#10;import logging&#10;import tempfile&#10;from services.file_service import FileService&#10;from services.ai_service import AIService&#10;&#10;# ...existing code...&#10;&#10;logger = logging.getLogger(&quot;studybuddy&quot;)&#10;app = Flask(__name__, template_folder=&quot;../templates&quot;, static_folder=&quot;../static&quot;)&#10;# enforce safe config&#10;app.config[&quot;MAX_CONTENT_LENGTH&quot;] = 12 * 1024 * 1024  # slightly above per-file limit&#10;&#10;file_service = FileService()&#10;# AI client should be injected; here we expect a lightweight stub for local usage&#10;class DummyClient:&#10;    def generate(self, prompt: str, timeout: int = 20, **kwargs):&#10;        # local stub — replace with real LLM client wrapper&#10;        return f&quot;[תשובת דמו ל: {prompt[:80]}]&quot;&#10;&#10;ai_service = AIService(client=DummyClient())&#10;&#10;@app.route(&quot;/&quot;)&#10;def home():&#10;    return render_template(&quot;home.html&quot;)&#10;&#10;@app.route(&quot;/api/summarize&quot;, methods=[&quot;POST&quot;])&#10;def summarize():&#10;    try:&#10;        # support pasted text or file upload&#10;        text = request.form.get(&quot;text&quot;, &quot;&quot;).strip()&#10;        if not text and &quot;file&quot; in request.files:&#10;            f = request.files[&quot;file&quot;]&#10;            uf = file_service.validate_and_store(f.stream, f.filename)&#10;            try:&#10;                text = file_service.extract_text(uf)&#10;            finally:&#10;                # clean temp on completion&#10;                file_service.clean_temp = getattr(file_service, &quot;clean_temp&quot;, None)&#10;                import os&#10;                from ..sb_utils.file_utils import clean_temp_path  # local import for merge safety&#10;                clean_temp_path(uf.temp_path)&#10;        if not text:&#10;            return jsonify({&quot;ok&quot;: False, &quot;error&quot;: &quot;לא הוזן טקסט או קובץ&quot;}), 400&#10;        # send to AI service (service layer)&#10;        result = ai_service.call(prompt=text, params={&quot;task&quot;: &quot;summarize&quot;})&#10;        return jsonify({&quot;ok&quot;: True, &quot;summary&quot;: result})&#10;    except ValueError as ve:&#10;        logger.debug(&quot;Validation error in summarize&quot;, exc_info=True)&#10;        return jsonify({&quot;ok&quot;: False, &quot;error&quot;: str(ve)}), 400&#10;    except Exception:&#10;        logger.exception(&quot;Unhandled error in summarize&quot;)&#10;        return jsonify({&quot;ok&quot;: False, &quot;error&quot;: &quot;אירעה שגיאה פנימית. אנא נסה שוב.&quot;}), 500&#10;&#10;# ...existing code...&#10;&#10;" />
              <option name="updatedContent" value="from flask import Flask, request, jsonify, render_template&#13;&#10;from typing import Dict&#13;&#10;import logging&#13;&#10;from services.file_service import FileService&#13;&#10;from services.ai_service import AIService&#13;&#10;&#13;&#10;logger = logging.getLogger(&quot;studybuddy&quot;)&#13;&#10;app = Flask(__name__, template_folder=&quot;../templates&quot;, static_folder=&quot;../static&quot;)&#13;&#10;# enforce safe config&#13;&#10;app.config[&quot;MAX_CONTENT_LENGTH&quot;] = 12 * 1024 * 1024  # slightly above per-file limit&#13;&#10;&#13;&#10;file_service = FileService()&#13;&#10;&#13;&#10;class DummyClient:&#13;&#10;    def generate(self, prompt: str, timeout: int = 20, **kwargs: Dict) -&gt; str:&#13;&#10;        # local stub — replace with real LLM client wrapper&#13;&#10;        return f&quot;[תשובת דמו ל: {prompt[:80]}]&quot;&#13;&#10;&#13;&#10;ai_service = AIService(client=DummyClient())&#13;&#10;&#13;&#10;@app.route(&quot;/&quot;)&#13;&#10;def home():&#13;&#10;    return render_template(&quot;home.html&quot;)&#13;&#10;&#13;&#10;@app.route(&quot;/api/summarize&quot;, methods=[&quot;POST&quot;])&#13;&#10;def summarize():&#13;&#10;    try:&#13;&#10;        # support pasted text or file upload&#13;&#10;        text: str = request.form.get(&quot;text&quot;, &quot;&quot;).strip()&#13;&#10;        uploaded = None&#13;&#10;&#13;&#10;        if not text and &quot;file&quot; in request.files:&#13;&#10;            f = request.files[&quot;file&quot;]&#13;&#10;            uploaded = file_service.validate_and_store(f.stream, f.filename)&#13;&#10;            try:&#13;&#10;                text = file_service.extract_text(uploaded)&#13;&#10;            finally:&#13;&#10;                # clean temp on completion&#13;&#10;                FileService.cleanup(uploaded)&#13;&#10;&#13;&#10;        if not text:&#13;&#10;            return jsonify({&quot;ok&quot;: False, &quot;error&quot;: &quot;לא הוזן טקסט או קובץ&quot;}), 400&#13;&#10;&#13;&#10;        # send to AI service (service layer)&#13;&#10;        result = ai_service.call(prompt=text, params={&quot;task&quot;: &quot;summarize&quot;})&#13;&#10;        return jsonify({&quot;ok&quot;: True, &quot;summary&quot;: result})&#13;&#10;    except ValueError as ve:&#13;&#10;        logger.debug(&quot;Validation error in summarize&quot;, exc_info=True)&#13;&#10;        return jsonify({&quot;ok&quot;: False, &quot;error&quot;: str(ve)}), 400&#13;&#10;    except Exception:&#13;&#10;        logger.exception(&quot;Unhandled error in summarize&quot;)&#13;&#10;        return jsonify({&quot;ok&quot;: False, &quot;error&quot;: &quot;אירעה שגיאה פנימית. אנא נסה שוב.&quot;}), 500" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/static/css/style.css">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/static/css/style.css" />
              <option name="originalContent" value="/* Cozy warm beige background, RTL, white rounded cards, soft shadows */&#10;:root {&#10;  --bg: #f5ebe0;&#10;  --card: #ffffff;&#10;  --muted: #6b5a4a;&#10;}&#10;&#10;html[dir=&quot;rtl&quot;], .rtl-root {&#10;  direction: rtl;&#10;  text-align: right;&#10;}&#10;&#10;body {&#10;  background: var(--bg);&#10;  color: #2b2b2b;&#10;  font-family: system-ui, -apple-system, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial;&#10;  margin: 0;&#10;  padding: 0;&#10;}&#10;&#10;.container {&#10;  max-width: 1100px;&#10;  margin: 24px auto;&#10;  padding: 16px;&#10;}&#10;&#10;.hero {&#10;  display: flex;&#10;  gap: 20px;&#10;  align-items: center;&#10;  margin-bottom: 20px;&#10;}&#10;&#10;/* Hero: Avner on left, text on right (RTL page so left visual) */&#10;.hero-left { flex: 1; }&#10;.hero-right { flex: 1; text-align: right; }&#10;&#10;.avner-hero { max-width: 320px; height: auto; object-fit: contain; }&#10;&#10;.tools-grid {&#10;  display: grid;&#10;  grid-template-columns: repeat(4, 1fr);&#10;  gap: 16px;&#10;}&#10;&#10;.tool-card {&#10;  background: var(--card);&#10;  border-radius: 12px;&#10;  padding: 16px;&#10;  box-shadow: 0 6px 18px rgba(0,0,0,0.06);&#10;}&#10;&#10;.tool-card .sticker { width: 120px; height: auto; display:block; margin-left: auto; margin-right: 0; }&#10;&#10;/* Mobile */&#10;@media (max-width: 768px) {&#10;  .hero { flex-direction: column-reverse; }&#10;  .tools-grid { grid-template-columns: 1fr; }&#10;  .tool-card .sticker { width: 180px; margin: 0 auto 8px auto; }&#10;  .nav-list { display: none; } /* expect hamburger handled elsewhere */&#10;}&#10;&#10;" />
              <option name="updatedContent" value="/* Cozy warm beige background, RTL, white rounded cards, soft shadows */&#13;&#10;:root {&#13;&#10;  --bg: #f5ebe0;&#13;&#10;  --card: #ffffff;&#13;&#10;  --muted: #6b5a4a;&#13;&#10;}&#13;&#10;&#13;&#10;html[dir=&quot;rtl&quot;], .rtl-root {&#13;&#10;  direction: rtl;&#13;&#10;  text-align: right;&#13;&#10;}&#13;&#10;&#13;&#10;body {&#13;&#10;  background: var(--bg);&#13;&#10;  color: #2b2b2b;&#13;&#10;  font-family: system-ui, -apple-system, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial;&#13;&#10;  margin: 0;&#13;&#10;  padding: 0;&#13;&#10;}&#13;&#10;&#13;&#10;.muted {&#13;&#10;  color: var(--muted);&#13;&#10;  font-size: 0.95rem;&#13;&#10;}&#13;&#10;&#13;&#10;.topnav {&#13;&#10;  background: #ffffff;&#13;&#10;  box-shadow: 0 2px 8px rgba(0,0,0,0.04);&#13;&#10;  padding: 8px 16px;&#13;&#10;}&#13;&#10;&#13;&#10;.nav-list {&#13;&#10;  list-style: none;&#13;&#10;  display: flex;&#13;&#10;  gap: 16px;&#13;&#10;  margin: 0;&#13;&#10;  padding: 0;&#13;&#10;}&#13;&#10;&#13;&#10;.nav-link {&#13;&#10;  text-decoration: none;&#13;&#10;  color: #444;&#13;&#10;}&#13;&#10;&#13;&#10;.nav-link:hover {&#13;&#10;  color: #000;&#13;&#10;}&#13;&#10;&#13;&#10;.container {&#13;&#10;  max-width: 1100px;&#13;&#10;  margin: 24px auto;&#13;&#10;  padding: 16px;&#13;&#10;}&#13;&#10;&#13;&#10;.hero {&#13;&#10;  display: flex;&#13;&#10;  gap: 20px;&#13;&#10;  align-items: center;&#13;&#10;  margin-bottom: 20px;&#13;&#10;}&#13;&#10;&#13;&#10;/* Hero: Avner on left, text on right (RTL page so left visual) */&#13;&#10;.hero-left { flex: 1; }&#13;&#10;.hero-right { flex: 1; text-align: right; }&#13;&#10;&#13;&#10;.avner-hero { max-width: 320px; height: auto; object-fit: contain; }&#13;&#10;&#13;&#10;.tools-grid {&#13;&#10;  display: grid;&#13;&#10;  grid-template-columns: repeat(4, 1fr);&#13;&#10;  gap: 16px;&#13;&#10;}&#13;&#10;&#13;&#10;.tool-card {&#13;&#10;  background: var(--card);&#13;&#10;  border-radius: 12px;&#13;&#10;  padding: 16px;&#13;&#10;  box-shadow: 0 6px 18px rgba(0,0,0,0.06);&#13;&#10;}&#13;&#10;&#13;&#10;.tool-link {&#13;&#10;  text-decoration: none;&#13;&#10;  color: inherit;&#13;&#10;  cursor: pointer;&#13;&#10;  display: block;&#13;&#10;}&#13;&#10;&#13;&#10;.tool-link:hover {&#13;&#10;  transform: translateY(-2px);&#13;&#10;  box-shadow: 0 10px 24px rgba(0,0,0,0.08);&#13;&#10;}&#13;&#10;&#13;&#10;.tool-card .sticker {&#13;&#10;  width: 120px;&#13;&#10;  height: auto;&#13;&#10;  display:block;&#13;&#10;  margin-left: auto;&#13;&#10;  margin-right: 0;&#13;&#10;}&#13;&#10;&#13;&#10;/* Mobile */&#13;&#10;@media (max-width: 768px) {&#13;&#10;  .hero { flex-direction: column-reverse; }&#13;&#10;  .tools-grid { grid-template-columns: 1fr; }&#13;&#10;  .tool-card .sticker { width: 180px; margin: 0 auto 8px auto; }&#13;&#10;  .nav-list { display: none; } /* expect hamburger handled elsewhere */&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/templates/base.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/templates/base.html" />
              <option name="originalContent" value="&lt;!doctype html&gt;&#10;&lt;html lang=&quot;he&quot; dir=&quot;rtl&quot;&gt;&#10;&lt;head&gt;&#10;  &lt;!-- ...existing head code... --&gt;&#10;  &lt;meta charset=&quot;utf-8&quot;/&gt;&#10;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;/&gt;&#10;  &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static', filename='css/style.css') }}&quot;&gt;&#10;  &lt;title&gt;StudyBuddyAI — אבנר ה-CapyBuddy&lt;/title&gt;&#10;&lt;/head&gt;&#10;&lt;body class=&quot;rtl-root&quot;&gt;&#10;  &lt;nav class=&quot;topnav&quot;&gt;&#10;    &lt;!-- exact nav labels --&gt;&#10;    &lt;ul class=&quot;nav-list&quot; role=&quot;navigation&quot;&gt;&#10;      &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;/&quot; class=&quot;nav-link&quot;&gt;בית&lt;/a&gt;&lt;/li&gt;&#10;      &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;/summarizer&quot; class=&quot;nav-link&quot;&gt;מסכם&lt;/a&gt;&lt;/li&gt;&#10;      &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;/flashcards&quot; class=&quot;nav-link&quot;&gt;כרטיסיות&lt;/a&gt;&lt;/li&gt;&#10;      &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;/assess&quot; class=&quot;nav-link&quot;&gt;בחן אותי&lt;/a&gt;&lt;/li&gt;&#10;      &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;/homework&quot; class=&quot;nav-link&quot;&gt;עוזר שיעורים&lt;/a&gt;&lt;/li&gt;&#10;    &lt;/ul&gt;&#10;    &lt;!-- ...existing nav code... --&gt;&#10;  &lt;/nav&gt;&#10;  &lt;main class=&quot;container&quot;&gt;&#10;    {% block content %}{% endblock %}&#10;  &lt;/main&gt;&#10;  &lt;!-- ...existing footer code... --&gt;&#10;&lt;/body&gt;&#10;&lt;/html&gt;&#10;&#10;" />
              <option name="updatedContent" value="&lt;!doctype html&gt;&#13;&#10;&lt;html lang=&quot;he&quot; dir=&quot;rtl&quot;&gt;&#13;&#10;&lt;head&gt;&#13;&#10;  &lt;!-- ...existing head code... --&gt;&#13;&#10;  &lt;meta charset=&quot;utf-8&quot;/&gt;&#13;&#10;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;/&gt;&#13;&#10;  &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static', filename='css/style.css') }}&quot;&gt;&#13;&#10;  &lt;title&gt;StudyBuddyAI — אבנר ה-CapyBuddy&lt;/title&gt;&#13;&#10;&lt;/head&gt;&#13;&#10;&lt;body class=&quot;rtl-root&quot;&gt;&#13;&#10;  &lt;nav class=&quot;topnav&quot;&gt;&#13;&#10;    &lt;!-- exact nav labels --&gt;&#13;&#10;    &lt;ul class=&quot;nav-list&quot; role=&quot;navigation&quot;&gt;&#13;&#10;      &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;/&quot; class=&quot;nav-link&quot;&gt;בית&lt;/a&gt;&lt;/li&gt;&#13;&#10;      &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;/summarizer&quot; class=&quot;nav-link&quot;&gt;מסכם&lt;/a&gt;&lt;/li&gt;&#13;&#10;      &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;/flashcards&quot; class=&quot;nav-link&quot;&gt;כרטיסיות&lt;/a&gt;&lt;/li&gt;&#13;&#10;      &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;/assess&quot; class=&quot;nav-link&quot;&gt;בחן אותי&lt;/a&gt;&lt;/li&gt;&#13;&#10;      &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;/homework&quot; class=&quot;nav-link&quot;&gt;עוזר שיעורים&lt;/a&gt;&lt;/li&gt;&#13;&#10;    &lt;/ul&gt;&#13;&#10;    &lt;!-- ...existing nav code... --&gt;&#13;&#10;  &lt;/nav&gt;&#13;&#10;  &lt;main class=&quot;container&quot;&gt;&#13;&#10;    {% block content %}{% endblock %}&#13;&#10;  &lt;/main&gt;&#13;&#10;  &lt;!-- ...existing footer code... --&gt;&#13;&#10;&lt;/body&gt;&#13;&#10;&lt;/html&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/templates/home.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/templates/home.html" />
              <option name="originalContent" value="{% extends &quot;base.html&quot; %}&#10;{% block content %}&#10;&lt;div class=&quot;hero&quot;&gt;&#10;  &lt;div class=&quot;hero-left&quot;&gt;&#10;    &lt;!-- Avner big pose on left --&gt;&#10;    &lt;img src=&quot;{{ url_for('static', filename='images/avner_laptop.png') }}&quot; alt=&quot;אבנר ה-CapyBuddy יושב מול המחשב&quot; class=&quot;avner-hero&quot;&gt;&#10;  &lt;/div&gt;&#10;  &lt;div class=&quot;hero-right&quot;&gt;&#10;    &lt;h1&gt;שלום! אני אבנר ה-CapyBuddy — כאן כדי לעזור לך ללמוד בקלות.&lt;/h1&gt;&#10;    &lt;p class=&quot;muted&quot;&gt;בחר כלי, העלה קובץ או הדבק טקסט והתחל ללמוד.&lt;/p&gt;&#10;  &lt;/div&gt;&#10;&lt;/div&gt;&#10;&#10;&lt;div class=&quot;tools-grid&quot;&gt;&#10;  &lt;!-- 4 cards; correct Avner stickers and alt text --&gt;&#10;  &lt;div class=&quot;tool-card&quot;&gt;&#10;    &lt;img src=&quot;{{ url_for('static', filename='images/avner_thinking.png') }}&quot; alt=&quot;אבנר ה-CapyBuddy חושב&quot; class=&quot;sticker&quot;&gt;&#10;    &lt;h3&gt;מסכם&lt;/h3&gt;&#10;    &lt;p&gt;קבל סיכום ידידותי וממוקד לטקסטים וקבצים.&lt;/p&gt;&#10;  &lt;/div&gt;&#10;  &lt;div class=&quot;tool-card&quot;&gt;&#10;    &lt;img src=&quot;{{ url_for('static', filename='images/avner_book.png') }}&quot; alt=&quot;אבנר ה-CapyBuddy עם ספר&quot; class=&quot;sticker&quot;&gt;&#10;    &lt;h3&gt;כרטיסיות&lt;/h3&gt;&#10;    &lt;p&gt;ייצור כרטיסיות לזיכרון ותרגול ממוקד.&lt;/p&gt;&#10;  &lt;/div&gt;&#10;  &lt;div class=&quot;tool-card&quot;&gt;&#10;    &lt;img src=&quot;{{ url_for('static', filename='images/avner_celebrate.png') }}&quot; alt=&quot;אבנר ה-CapyBuddy חוגג&quot; class=&quot;sticker&quot;&gt;&#10;    &lt;h3&gt;בחן אותי&lt;/h3&gt;&#10;    &lt;p&gt;שאלות אימון מותאמות לרמה שלך.&lt;/p&gt;&#10;  &lt;/div&gt;&#10;  &lt;div class=&quot;tool-card&quot;&gt;&#10;    &lt;img src=&quot;{{ url_for('static', filename='images/avner_teaching.png') }}&quot; alt=&quot;אבנר ה-CapyBuddy מלמד&quot; class=&quot;sticker&quot;&gt;&#10;    &lt;h3&gt;עוזר שיעורים&lt;/h3&gt;&#10;    &lt;p&gt;הסברים ידידותיים וצעד־אצעד לשיעורי בית.&lt;/p&gt;&#10;  &lt;/div&gt;&#10;&lt;/div&gt;&#10;{% endblock %}&#10;&#10;" />
              <option name="updatedContent" value="{% extends &quot;base.html&quot; %}&#13;&#10;{% block content %}&#13;&#10;&lt;div class=&quot;hero&quot;&gt;&#13;&#10;  &lt;div class=&quot;hero-left&quot;&gt;&#13;&#10;    &lt;!-- Avner big pose on left --&gt;&#13;&#10;    &lt;img src=&quot;{{ url_for('static', filename='images/avner_laptop.png') }}&quot; alt=&quot;אבנר ה-CapyBuddy יושב מול המחשב&quot; class=&quot;avner-hero&quot;&gt;&#13;&#10;  &lt;/div&gt;&#13;&#10;  &lt;div class=&quot;hero-right&quot;&gt;&#13;&#10;    &lt;h1&gt;שלום! אני אבנר ה-CapyBuddy — כאן כדי לעזור לך ללמוד בקלות.&lt;/h1&gt;&#13;&#10;    &lt;p class=&quot;muted&quot;&gt;בחר כלי, העלה קובץ או הדבק טקסט והתחל ללמוד.&lt;/p&gt;&#13;&#10;  &lt;/div&gt;&#13;&#10;&lt;/div&gt;&#13;&#10;&#13;&#10;&lt;div class=&quot;tools-grid&quot;&gt;&#13;&#10;  &lt;!-- 4 cards; correct Avner stickers and alt text --&gt;&#13;&#10;  &lt;a href=&quot;/summarizer&quot; class=&quot;tool-card tool-link&quot;&gt;&#13;&#10;    &lt;img src=&quot;{{ url_for('static', filename='images/avner_thinking.png') }}&quot; alt=&quot;אבנר ה-CapyBuddy חושב&quot; class=&quot;sticker&quot;&gt;&#13;&#10;    &lt;h3&gt;מסכם&lt;/h3&gt;&#13;&#10;    &lt;p&gt;קבל סיכום ידידותי וממוקד לטקסטים וקבצים.&lt;/p&gt;&#13;&#10;  &lt;/a&gt;&#13;&#10;  &lt;a href=&quot;/flashcards&quot; class=&quot;tool-card tool-link&quot;&gt;&#13;&#10;    &lt;img src=&quot;{{ url_for('static', filename='images/avner_book.png') }}&quot; alt=&quot;אבנר ה-CapyBuddy עם ספר&quot; class=&quot;sticker&quot;&gt;&#13;&#10;    &lt;h3&gt;כרטיסיות&lt;/h3&gt;&#13;&#10;    &lt;p&gt;ייצור כרטיסיות לזיכרון ותרגול ממוקד.&lt;/p&gt;&#13;&#10;  &lt;/a&gt;&#13;&#10;  &lt;a href=&quot;/assess&quot; class=&quot;tool-card tool-link&quot;&gt;&#13;&#10;    &lt;img src=&quot;{{ url_for('static', filename='images/avner_celebrate.png') }}&quot; alt=&quot;אבנר ה-CapyBuddy חוגג&quot; class=&quot;sticker&quot;&gt;&#13;&#10;    &lt;h3&gt;בחן אותי&lt;/h3&gt;&#13;&#10;    &lt;p&gt;שאלות אימון מותאמות לרמה שלך.&lt;/p&gt;&#13;&#10;  &lt;/a&gt;&#13;&#10;  &lt;a href=&quot;/homework&quot; class=&quot;tool-card tool-link&quot;&gt;&#13;&#10;    &lt;img src=&quot;{{ url_for('static', filename='images/avner_teaching.png') }}&quot; alt=&quot;אבנר ה-CapyBuddy מלמד&quot; class=&quot;sticker&quot;&gt;&#13;&#10;    &lt;h3&gt;עוזר שיעורים&lt;/h3&gt;&#13;&#10;    &lt;p&gt;הסברים ידידותיים וצעד־אצעד לשיעורי בית.&lt;/p&gt;&#13;&#10;  &lt;/a&gt;&#13;&#10;&lt;/div&gt;&#13;&#10;{% endblock %}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/test_tools_api.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/test_tools_api.py" />
              <option name="originalContent" value="import io&#10;import pytest&#10;from unittest.mock import patch, MagicMock&#10;from src.api import app&#10;&#10;@pytest.fixture&#10;def client():&#10;    app.testing = True&#10;    with app.test_client() as c:&#10;        yield c&#10;&#10;def test_summarize_empty(client):&#10;    r = client.post(&quot;/api/summarize&quot;, data={})&#10;    assert r.status_code == 400&#10;    assert &quot;לא הוזן טקסט&quot; in r.get_json().get(&quot;error&quot;, &quot;&quot;)&#10;&#10;@patch(&quot;src.api.ai_service&quot;)&#10;def test_summarize_text(mock_ai_service, client):&#10;    mock_ai_service.call = MagicMock(return_value=&quot;תקציר לבדיקה&quot;)&#10;    r = client.post(&quot;/api/summarize&quot;, data={&quot;text&quot;: &quot;זה טקסט לבדיקה&quot;})&#10;    assert r.status_code == 200&#10;    assert r.get_json()[&quot;summary&quot;] == &quot;תקציר לבדיקה&quot;&#10;&#10;def test_upload_wrong_type(client):&#10;    data = {&#10;        &quot;file&quot;: (io.BytesIO(b&quot;dummy&quot;), &quot;test.exe&quot;)&#10;    }&#10;    r = client.post(&quot;/api/summarize&quot;, data=data, content_type=&quot;multipart/form-data&quot;)&#10;    # Should return 400 with friendly message&#10;    assert r.status_code in (400, 413)&#10;&#10;# Additional tests (AI error / DB failure) should mock services similarly.&#10;&#10;" />
              <option name="updatedContent" value="import io&#13;&#10;import pytest&#13;&#10;from unittest.mock import patch, MagicMock&#13;&#10;from src.api import app&#13;&#10;&#13;&#10;@pytest.fixture&#13;&#10;def client():&#13;&#10;    app.testing = True&#13;&#10;    with app.test_client() as c:&#13;&#10;        yield c&#13;&#10;&#13;&#10;def test_summarize_empty(client):&#13;&#10;    r = client.post(&quot;/api/summarize&quot;, data={})&#13;&#10;    assert r.status_code == 400&#13;&#10;    assert &quot;לא הוזן טקסט&quot; in r.get_json().get(&quot;error&quot;, &quot;&quot;)&#13;&#10;&#13;&#10;@patch(&quot;src.api.ai_service&quot;)&#13;&#10;def test_summarize_text(mock_ai_service, client):&#13;&#10;    mock_ai_service.call = MagicMock(return_value=&quot;תקציר לבדיקה&quot;)&#13;&#10;    r = client.post(&quot;/api/summarize&quot;, data={&quot;text&quot;: &quot;זה טקסט לבדיקה&quot;})&#13;&#10;    assert r.status_code == 200&#13;&#10;    assert r.get_json()[&quot;summary&quot;] == &quot;תקציר לבדיקה&quot;&#13;&#10;&#13;&#10;def test_upload_wrong_type(client):&#13;&#10;    data = {&#13;&#10;        &quot;file&quot;: (io.BytesIO(b&quot;dummy&quot;), &quot;test.exe&quot;)&#13;&#10;    }&#13;&#10;    r = client.post(&quot;/api/summarize&quot;, data=data, content_type=&quot;multipart/form-data&quot;)&#13;&#10;    # Should return 400 with friendly message or be blocked by max-size/MIME&#13;&#10;    assert r.status_code in (400, 413)&#13;&#10;&#13;&#10;# Additional tests (AI error / DB failure) should mock services similarly." />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>