<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/infra/mongo_client.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/infra/mongo_client.py" />
              <option name="originalContent" value="from typing import Any, Dict, Optional&#10;from pymongo import MongoClient, ASCENDING&#10;import logging&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class MongoClientWrapper:&#10;    def __init__(self, uri: str = &quot;mongodb://localhost:27017&quot;, db_name: str = &quot;studybuddy&quot;):&#10;        self._client = MongoClient(uri, serverSelectionTimeoutMS=2000)&#10;        self.db = self._client[db_name]&#10;        self._ensure_indexes()&#10;&#10;    def _ensure_indexes(self):&#10;        # Example indexes — add as needed for queries (no unique on user content)&#10;        try:&#10;            self.db.jobs.create_index([(&quot;created_at&quot;, ASCENDING)])&#10;        except Exception:&#10;            logger.warning(&quot;Failed to create indexes on MongoDB&quot;, exc_info=True)&#10;&#10;    def insert_job(self, collection: str, job: Dict[str, Any]) -&gt; str:&#10;        # Safe insert; ensure no direct user content used in queries&#10;        res = self.db[collection].insert_one(job)&#10;        return str(res.inserted_id)&#10;&#10;    def find_job(self, collection: str, job_id: Any) -&gt; Optional[Dict]:&#10;        res = self.db[collection].find_one({&quot;_id&quot;: job_id})&#10;        return res&#10;&#10;" />
              <option name="updatedContent" value="from typing import Any, Dict, Optional&#13;&#10;from bson import ObjectId&#13;&#10;from pymongo import MongoClient, ASCENDING&#13;&#10;import logging&#13;&#10;&#13;&#10;logger = logging.getLogger(__name__)&#13;&#10;&#13;&#10;class MongoClientWrapper:&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    Thin wrapper around MongoClient to centralize indexes and safe patterns.&#13;&#10;    &quot;&quot;&quot;&#13;&#10;&#13;&#10;    def __init__(self, uri: str = &quot;mongodb://localhost:27017&quot;, db_name: str = &quot;studybuddy&quot;) -&gt; None:&#13;&#10;        self._client = MongoClient(uri, serverSelectionTimeoutMS=2000)&#13;&#10;        self.db = self._client[db_name]&#13;&#10;        self._ensure_indexes()&#13;&#10;&#13;&#10;    def _ensure_indexes(self) -&gt; None:&#13;&#10;        # Example indexes — add as needed for queries (no unique on user content)&#13;&#10;        try:&#13;&#10;            self.db.jobs.create_index([(&quot;created_at&quot;, ASCENDING)])&#13;&#10;        except Exception:&#13;&#10;            logger.warning(&quot;Failed to create indexes on MongoDB&quot;, exc_info=True)&#13;&#10;&#13;&#10;    def insert_job(self, collection: str, job: Dict[str, Any]) -&gt; str:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Insert a job document and return its ID as string.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        res = self.db[collection].insert_one(job)&#13;&#10;        return str(res.inserted_id)&#13;&#10;&#13;&#10;    def find_job(self, collection: str, job_id: Any) -&gt; Optional[Dict[str, Any]]:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Find a job document by its ID (string or ObjectId).&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        oid = ObjectId(job_id) if not isinstance(job_id, ObjectId) else job_id&#13;&#10;        res = self.db[collection].find_one({&quot;_id&quot;: oid})&#13;&#10;        return res" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/sb_utils/validation.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sb_utils/validation.py" />
              <option name="originalContent" value="from typing import Optional&#10;from .file_utils import allowed_mimetype, MAX_FILE_SIZE_BYTES&#10;import logging&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;# user-facing messages (use enums / constants)&#10;HEBREW_ERRORS = {&#10;    &quot;no_input&quot;: &quot;לא הוזן טקסט או קובץ. אנא העתק טקסט או העלה קובץ.&quot;,&#10;    &quot;bad_type&quot;: &quot;סוג הקובץ אינו נתמך. אנא העלה PDF, DOCX, TXT או תמונה (PNG/JPEG).&quot;,&#10;    &quot;too_large&quot;: &quot;הקובץ גדול מדי. אנא השתמש בקבצים עד 10MB.&quot;,&#10;    &quot;server_error&quot;: &quot;אירעה שגיאה בשרת. נסה שוב מאוחר יותר.&quot;,&#10;}&#10;&#10;def validate_upload(mime: Optional[str], size: int) -&gt; Optional[str]:&#10;    if size &lt;= 0:&#10;        return HEBREW_ERRORS[&quot;no_input&quot;]&#10;    if size &gt; MAX_FILE_SIZE_BYTES:&#10;        return HEBREW_ERRORS[&quot;too_large&quot;]&#10;    if not allowed_mimetype(mime):&#10;        return HEBREW_ERRORS[&quot;bad_type&quot;]&#10;    return None&#10;&#10;" />
              <option name="updatedContent" value="from typing import Optional&#13;&#10;from .file_utils import allowed_mimetype, MAX_FILE_SIZE_BYTES&#13;&#10;import logging&#13;&#10;&#13;&#10;logger = logging.getLogger(__name__)&#13;&#10;&#13;&#10;# user-facing messages (use enums / constants)&#13;&#10;HEBREW_ERRORS = {&#13;&#10;    &quot;no_input&quot;: &quot;לא הוזן טקסט או קובץ. אנא העתק טקסט או העלה קובץ.&quot;,&#13;&#10;    &quot;bad_type&quot;: &quot;סוג הקובץ אינו נתמך. אנא העלה PDF, DOCX, TXT או תמונה (PNG/JPEG).&quot;,&#13;&#10;    &quot;too_large&quot;: &quot;הקובץ גדול מדי. אנא השתמש בקבצים עד 10MB.&quot;,&#13;&#10;    &quot;server_error&quot;: &quot;אירעה שגיאה בשרת. נסה שוב מאוחר יותר.&quot;,&#13;&#10;}&#13;&#10;&#13;&#10;def validate_upload(mime: Optional[str], size: int) -&gt; Optional[str]:&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    Validate upload size and MIME type.&#13;&#10;    Returns a Hebrew error message if invalid, otherwise None.&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    if size &lt;= 0:&#13;&#10;        logger.debug(&quot;Validation failed: empty upload (size=%d)&quot;, size)&#13;&#10;        return HEBREW_ERRORS[&quot;no_input&quot;]&#13;&#10;    if size &gt; MAX_FILE_SIZE_BYTES:&#13;&#10;        logger.debug(&quot;Validation failed: too large (size=%d)&quot;, size)&#13;&#10;        return HEBREW_ERRORS[&quot;too_large&quot;]&#13;&#10;    if not allowed_mimetype(mime):&#13;&#10;        logger.debug(&quot;Validation failed: bad MIME type (%s)&quot;, mime)&#13;&#10;        return HEBREW_ERRORS[&quot;bad_type&quot;]&#13;&#10;    return None" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/services/ai_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/services/ai_service.py" />
              <option name="originalContent" value="from typing import Any, Dict, Optional&#10;import time&#10;import logging&#10;import random&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class AIService:&#10;    &quot;&quot;&quot;&#10;    Wrapper for LLM calls. Retries with exponential backoff, timeout per-call.&#10;    Important: DO NOT log user content or API keys.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, client: Any, timeout_s: int = 20, retries: int = 2):&#10;        self.client = client  # injected LLM client wrapper&#10;        self.timeout_s = timeout_s&#10;        self.retries = retries&#10;&#10;    def call(self, prompt: str, params: Optional[Dict] = None) -&gt; str:&#10;        if not prompt or not prompt.strip():&#10;            raise ValueError(&quot;empty_prompt&quot;)&#10;        params = params or {}&#10;        attempt = 0&#10;        while True:&#10;            try:&#10;                attempt += 1&#10;                # call must honor timeout - client implementation should support it&#10;                response = self.client.generate(prompt=prompt, timeout=self.timeout_s, **params)&#10;                # response must be sanitized by client&#10;                return response&#10;            except Exception as exc:&#10;                logger.debug(&quot;AI call failed attempt %d: %s&quot;, attempt, type(exc).__name__)&#10;                if attempt &gt; self.retries:&#10;                    logger.warning(&quot;AI service unavailable after %d attempts&quot;, attempt)&#10;                    raise&#10;                # backoff with jitter&#10;                backoff = (2 ** attempt) + random.random()&#10;                time.sleep(backoff)&#10;&#10;" />
              <option name="updatedContent" value="from typing import Any, Dict, Optional&#13;&#10;import time&#13;&#10;import logging&#13;&#10;import random&#13;&#10;&#13;&#10;logger = logging.getLogger(__name__)&#13;&#10;&#13;&#10;class AIService:&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    Wrapper for LLM calls. Retries with exponential backoff, timeout per-call.&#13;&#10;    Important: DO NOT log user content or API keys.&#13;&#10;    &quot;&quot;&quot;&#13;&#10;&#13;&#10;    def __init__(self, client: Any, timeout_s: int = 20, retries: int = 2) -&gt; None:&#13;&#10;        self.client = client  # injected LLM client wrapper&#13;&#10;        self.timeout_s = timeout_s&#13;&#10;        self.retries = retries&#13;&#10;&#13;&#10;    def call(self, prompt: str, params: Optional[Dict[str, Any]] = None) -&gt; str:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Perform a robust LLM call with retries.&#13;&#10;        The client is responsible for honoring the timeout parameter.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if not prompt or not prompt.strip():&#13;&#10;            raise ValueError(&quot;empty_prompt&quot;)&#13;&#10;        params = params or {}&#13;&#10;        attempt = 0&#13;&#10;        while True:&#13;&#10;            try:&#13;&#10;                attempt += 1&#13;&#10;                response: str = self.client.generate(&#13;&#10;                    prompt=prompt,&#13;&#10;                    timeout=self.timeout_s,&#13;&#10;                    **params,&#13;&#10;                )&#13;&#10;                return response&#13;&#10;            except Exception as exc:&#13;&#10;                logger.debug(&quot;AI call failed attempt %d: %s&quot;, attempt, type(exc).__name__)&#13;&#10;                if attempt &gt; self.retries:&#13;&#10;                    logger.warning(&quot;AI service unavailable after %d attempts&quot;, attempt)&#13;&#10;                    raise&#13;&#10;                backoff: float = (2 ** attempt) + random.random()&#13;&#10;                time.sleep(backoff)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/services/file_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/services/file_service.py" />
              <option name="originalContent" value="from typing import Optional&#10;import logging&#10;from ..sb_utils.file_utils import save_stream_to_temp, clean_temp_path, UploadedFile&#10;from ..sb_utils.validation import validate_upload, HEBREW_ERRORS&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class FileService:&#10;    &quot;&quot;&quot;&#10;    Handles user files: validation, safe temp storage, lightweight extraction.&#10;    Extraction itself can be implemented using optional libs; here we keep API simple.&#10;    &quot;&quot;&quot;&#10;&#10;    def validate_and_store(self, stream, filename: str) -&gt; UploadedFile:&#10;        uf = save_stream_to_temp(stream, filename)&#10;        # do not log contents or names that could be sensitive (only size/mime)&#10;        logger.debug(&quot;Stored temp file (size=%d, mime=%s)&quot;, uf.size, uf.content_type)&#10;        err = validate_upload(uf.content_type, uf.size)&#10;        if err:&#10;            clean_temp_path(uf.temp_path)&#10;            raise ValueError(err)&#10;        return uf&#10;&#10;    def extract_text(self, uploaded: UploadedFile) -&gt; str:&#10;        # Lightweight extraction: for TXT, read; for others return placeholder instruction.&#10;        # Real extraction should be implemented via dedicated extractors (pdfminer, docx2txt...)&#10;        try:&#10;            if uploaded.content_type == &quot;text/plain&quot;:&#10;                with open(uploaded.temp_path, &quot;r&quot;, encoding=&quot;utf-8&quot;, errors=&quot;ignore&quot;) as f:&#10;                    return f.read()&#10;            # keep fallback small and explicit&#10;            return f&quot;[קובץ נתמך: {uploaded.filename} — טקסט לא הופק אוטומטית]&quot;&#10;        finally:&#10;            # caller decides when to clean&#10;            pass&#10;&#10;" />
              <option name="updatedContent" value="from typing import IO&#13;&#10;import logging&#13;&#10;from sb_utils.file_utils import save_stream_to_temp, clean_temp_path, UploadedFile&#13;&#10;from sb_utils.validation import validate_upload&#13;&#10;&#13;&#10;logger = logging.getLogger(__name__)&#13;&#10;&#13;&#10;class FileService:&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    Handles user files: validation, safe temp storage, lightweight extraction.&#13;&#10;    Extraction itself can be implemented using optional libs; here we keep API simple.&#13;&#10;    &quot;&quot;&quot;&#13;&#10;&#13;&#10;    def validate_and_store(self, stream: IO[bytes], filename: str) -&gt; UploadedFile:&#13;&#10;        uf = save_stream_to_temp(stream, filename)&#13;&#10;        # do not log contents or names that could be sensitive (only size/mime)&#13;&#10;        logger.debug(&quot;Stored temp file (size=%d, mime=%s)&quot;, uf.size, uf.content_type)&#13;&#10;        err = validate_upload(uf.content_type, uf.size)&#13;&#10;        if err:&#13;&#10;            clean_temp_path(uf.temp_path)&#13;&#10;            raise ValueError(err)&#13;&#10;        return uf&#13;&#10;&#13;&#10;    def extract_text(self, uploaded: UploadedFile) -&gt; str:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Lightweight extraction: for TXT, read; for others return placeholder instruction.&#13;&#10;        Real extraction should be implemented via dedicated extractors (pdfminer, docx2txt...).&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        try:&#13;&#10;            if uploaded.content_type == &quot;text/plain&quot;:&#13;&#10;                with open(uploaded.temp_path, &quot;r&quot;, encoding=&quot;utf-8&quot;, errors=&quot;ignore&quot;) as f:&#13;&#10;                    return f.read()&#13;&#10;            # keep fallback small and explicit&#13;&#10;            return f&quot;[קובץ נתמך: {uploaded.filename} — טקסט לא הופק אוטומטית]&quot;&#13;&#10;        finally:&#13;&#10;            # caller decides when to clean&#13;&#10;            pass&#13;&#10;&#13;&#10;    @staticmethod&#13;&#10;    def cleanup(uploaded: UploadedFile) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Public helper so routes/tests do not touch filesystem utils directly.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        clean_temp_path(uploaded.temp_path)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/api.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/api.py" />
              <option name="originalContent" value="from flask import Flask, request, jsonify, render_template&#10;from typing import Dict&#10;import logging&#10;import tempfile&#10;from services.file_service import FileService&#10;from services.ai_service import AIService&#10;&#10;# ...existing code...&#10;&#10;logger = logging.getLogger(&quot;studybuddy&quot;)&#10;app = Flask(__name__, template_folder=&quot;../templates&quot;, static_folder=&quot;../static&quot;)&#10;# enforce safe config&#10;app.config[&quot;MAX_CONTENT_LENGTH&quot;] = 12 * 1024 * 1024  # slightly above per-file limit&#10;&#10;file_service = FileService()&#10;# AI client should be injected; here we expect a lightweight stub for local usage&#10;class DummyClient:&#10;    def generate(self, prompt: str, timeout: int = 20, **kwargs):&#10;        # local stub — replace with real LLM client wrapper&#10;        return f&quot;[תשובת דמו ל: {prompt[:80]}]&quot;&#10;&#10;ai_service = AIService(client=DummyClient())&#10;&#10;@app.route(&quot;/&quot;)&#10;def home():&#10;    return render_template(&quot;home.html&quot;)&#10;&#10;@app.route(&quot;/api/summarize&quot;, methods=[&quot;POST&quot;])&#10;def summarize():&#10;    try:&#10;        # support pasted text or file upload&#10;        text = request.form.get(&quot;text&quot;, &quot;&quot;).strip()&#10;        if not text and &quot;file&quot; in request.files:&#10;            f = request.files[&quot;file&quot;]&#10;            uf = file_service.validate_and_store(f.stream, f.filename)&#10;            try:&#10;                text = file_service.extract_text(uf)&#10;            finally:&#10;                # clean temp on completion&#10;                file_service.clean_temp = getattr(file_service, &quot;clean_temp&quot;, None)&#10;                import os&#10;                from ..sb_utils.file_utils import clean_temp_path  # local import for merge safety&#10;                clean_temp_path(uf.temp_path)&#10;        if not text:&#10;            return jsonify({&quot;ok&quot;: False, &quot;error&quot;: &quot;לא הוזן טקסט או קובץ&quot;}), 400&#10;        # send to AI service (service layer)&#10;        result = ai_service.call(prompt=text, params={&quot;task&quot;: &quot;summarize&quot;})&#10;        return jsonify({&quot;ok&quot;: True, &quot;summary&quot;: result})&#10;    except ValueError as ve:&#10;        logger.debug(&quot;Validation error in summarize&quot;, exc_info=True)&#10;        return jsonify({&quot;ok&quot;: False, &quot;error&quot;: str(ve)}), 400&#10;    except Exception:&#10;        logger.exception(&quot;Unhandled error in summarize&quot;)&#10;        return jsonify({&quot;ok&quot;: False, &quot;error&quot;: &quot;אירעה שגיאה פנימית. אנא נסה שוב.&quot;}), 500&#10;&#10;# ...existing code...&#10;&#10;" />
              <option name="updatedContent" value="from flask import Flask, request, jsonify, render_template&#13;&#10;from typing import Dict&#13;&#10;import logging&#13;&#10;from services.file_service import FileService&#13;&#10;from services.ai_service import AIService&#13;&#10;&#13;&#10;logger = logging.getLogger(&quot;studybuddy&quot;)&#13;&#10;app = Flask(__name__, template_folder=&quot;../templates&quot;, static_folder=&quot;../static&quot;)&#13;&#10;# enforce safe config&#13;&#10;app.config[&quot;MAX_CONTENT_LENGTH&quot;] = 12 * 1024 * 1024  # slightly above per-file limit&#13;&#10;&#13;&#10;file_service = FileService()&#13;&#10;&#13;&#10;class DummyClient:&#13;&#10;    def generate(self, prompt: str, timeout: int = 20, **kwargs: Dict) -&gt; str:&#13;&#10;        # local stub — replace with real LLM client wrapper&#13;&#10;        return f&quot;[תשובת דמו ל: {prompt[:80]}]&quot;&#13;&#10;&#13;&#10;ai_service = AIService(client=DummyClient())&#13;&#10;&#13;&#10;@app.route(&quot;/&quot;)&#13;&#10;def home():&#13;&#10;    return render_template(&quot;home.html&quot;)&#13;&#10;&#13;&#10;@app.route(&quot;/api/summarize&quot;, methods=[&quot;POST&quot;])&#13;&#10;def summarize():&#13;&#10;    try:&#13;&#10;        # support pasted text or file upload&#13;&#10;        text: str = request.form.get(&quot;text&quot;, &quot;&quot;).strip()&#13;&#10;        uploaded = None&#13;&#10;&#13;&#10;        if not text and &quot;file&quot; in request.files:&#13;&#10;            f = request.files[&quot;file&quot;]&#13;&#10;            uploaded = file_service.validate_and_store(f.stream, f.filename)&#13;&#10;            try:&#13;&#10;                text = file_service.extract_text(uploaded)&#13;&#10;            finally:&#13;&#10;                # clean temp on completion&#13;&#10;                FileService.cleanup(uploaded)&#13;&#10;&#13;&#10;        if not text:&#13;&#10;            return jsonify({&quot;ok&quot;: False, &quot;error&quot;: &quot;לא הוזן טקסט או קובץ&quot;}), 400&#13;&#10;&#13;&#10;        # send to AI service (service layer)&#13;&#10;        result = ai_service.call(prompt=text, params={&quot;task&quot;: &quot;summarize&quot;})&#13;&#10;        return jsonify({&quot;ok&quot;: True, &quot;summary&quot;: result})&#13;&#10;    except ValueError as ve:&#13;&#10;        logger.debug(&quot;Validation error in summarize&quot;, exc_info=True)&#13;&#10;        return jsonify({&quot;ok&quot;: False, &quot;error&quot;: str(ve)}), 400&#13;&#10;    except Exception:&#13;&#10;        logger.exception(&quot;Unhandled error in summarize&quot;)&#13;&#10;        return jsonify({&quot;ok&quot;: False, &quot;error&quot;: &quot;אירעה שגיאה פנימית. אנא נסה שוב.&quot;}), 500" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/static/css/style.css">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/static/css/style.css" />
              <option name="originalContent" value="/* Cozy warm beige background, RTL, white rounded cards, soft shadows */&#10;:root {&#10;  --bg: #f5ebe0;&#10;  --card: #ffffff;&#10;  --muted: #6b5a4a;&#10;}&#10;&#10;html[dir=&quot;rtl&quot;], .rtl-root {&#10;  direction: rtl;&#10;  text-align: right;&#10;}&#10;&#10;body {&#10;  background: var(--bg);&#10;  color: #2b2b2b;&#10;  font-family: system-ui, -apple-system, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial;&#10;  margin: 0;&#10;  padding: 0;&#10;}&#10;&#10;.container {&#10;  max-width: 1100px;&#10;  margin: 24px auto;&#10;  padding: 16px;&#10;}&#10;&#10;.hero {&#10;  display: flex;&#10;  gap: 20px;&#10;  align-items: center;&#10;  margin-bottom: 20px;&#10;}&#10;&#10;/* Hero: Avner on left, text on right (RTL page so left visual) */&#10;.hero-left { flex: 1; }&#10;.hero-right { flex: 1; text-align: right; }&#10;&#10;.avner-hero { max-width: 320px; height: auto; object-fit: contain; }&#10;&#10;.tools-grid {&#10;  display: grid;&#10;  grid-template-columns: repeat(4, 1fr);&#10;  gap: 16px;&#10;}&#10;&#10;.tool-card {&#10;  background: var(--card);&#10;  border-radius: 12px;&#10;  padding: 16px;&#10;  box-shadow: 0 6px 18px rgba(0,0,0,0.06);&#10;}&#10;&#10;.tool-card .sticker { width: 120px; height: auto; display:block; margin-left: auto; margin-right: 0; }&#10;&#10;/* Mobile */&#10;@media (max-width: 768px) {&#10;  .hero { flex-direction: column-reverse; }&#10;  .tools-grid { grid-template-columns: 1fr; }&#10;  .tool-card .sticker { width: 180px; margin: 0 auto 8px auto; }&#10;  .nav-list { display: none; } /* expect hamburger handled elsewhere */&#10;}&#10;&#10;" />
              <option name="updatedContent" value="/* Cozy warm beige background, RTL, white rounded cards, soft shadows */&#13;&#10;:root {&#13;&#10;  --bg: #f5ebe0;&#13;&#10;  --card: #ffffff;&#13;&#10;  --muted: #6b5a4a;&#13;&#10;}&#13;&#10;&#13;&#10;html[dir=&quot;rtl&quot;], .rtl-root {&#13;&#10;  direction: rtl;&#13;&#10;  text-align: right;&#13;&#10;}&#13;&#10;&#13;&#10;body {&#13;&#10;  background: var(--bg);&#13;&#10;  color: #2b2b2b;&#13;&#10;  font-family: system-ui, -apple-system, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial;&#13;&#10;  margin: 0;&#13;&#10;  padding: 0;&#13;&#10;}&#13;&#10;&#13;&#10;.muted {&#13;&#10;  color: var(--muted);&#13;&#10;  font-size: 0.95rem;&#13;&#10;}&#13;&#10;&#13;&#10;.topnav {&#13;&#10;  background: #ffffff;&#13;&#10;  box-shadow: 0 2px 8px rgba(0,0,0,0.04);&#13;&#10;  padding: 8px 16px;&#13;&#10;}&#13;&#10;&#13;&#10;.nav-list {&#13;&#10;  list-style: none;&#13;&#10;  display: flex;&#13;&#10;  gap: 16px;&#13;&#10;  margin: 0;&#13;&#10;  padding: 0;&#13;&#10;}&#13;&#10;&#13;&#10;.nav-link {&#13;&#10;  text-decoration: none;&#13;&#10;  color: #444;&#13;&#10;}&#13;&#10;&#13;&#10;.nav-link:hover {&#13;&#10;  color: #000;&#13;&#10;}&#13;&#10;&#13;&#10;.container {&#13;&#10;  max-width: 1100px;&#13;&#10;  margin: 24px auto;&#13;&#10;  padding: 16px;&#13;&#10;}&#13;&#10;&#13;&#10;.hero {&#13;&#10;  display: flex;&#13;&#10;  gap: 20px;&#13;&#10;  align-items: center;&#13;&#10;  margin-bottom: 20px;&#13;&#10;}&#13;&#10;&#13;&#10;/* Hero: Avner on left, text on right (RTL page so left visual) */&#13;&#10;.hero-left { flex: 1; }&#13;&#10;.hero-right { flex: 1; text-align: right; }&#13;&#10;&#13;&#10;.avner-hero { max-width: 320px; height: auto; object-fit: contain; }&#13;&#10;&#13;&#10;.tools-grid {&#13;&#10;  display: grid;&#13;&#10;  grid-template-columns: repeat(4, 1fr);&#13;&#10;  gap: 16px;&#13;&#10;}&#13;&#10;&#13;&#10;.tool-card {&#13;&#10;  background: var(--card);&#13;&#10;  border-radius: 12px;&#13;&#10;  padding: 16px;&#13;&#10;  box-shadow: 0 6px 18px rgba(0,0,0,0.06);&#13;&#10;}&#13;&#10;&#13;&#10;.tool-link {&#13;&#10;  text-decoration: none;&#13;&#10;  color: inherit;&#13;&#10;  cursor: pointer;&#13;&#10;  display: block;&#13;&#10;}&#13;&#10;&#13;&#10;.tool-link:hover {&#13;&#10;  transform: translateY(-2px);&#13;&#10;  box-shadow: 0 10px 24px rgba(0,0,0,0.08);&#13;&#10;}&#13;&#10;&#13;&#10;.tool-card .sticker {&#13;&#10;  width: 120px;&#13;&#10;  height: auto;&#13;&#10;  display:block;&#13;&#10;  margin-left: auto;&#13;&#10;  margin-right: 0;&#13;&#10;}&#13;&#10;&#13;&#10;/* Mobile */&#13;&#10;@media (max-width: 768px) {&#13;&#10;  .hero { flex-direction: column-reverse; }&#13;&#10;  .tools-grid { grid-template-columns: 1fr; }&#13;&#10;  .tool-card .sticker { width: 180px; margin: 0 auto 8px auto; }&#13;&#10;  .nav-list { display: none; } /* expect hamburger handled elsewhere */&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>